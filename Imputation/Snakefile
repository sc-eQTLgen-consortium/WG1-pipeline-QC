#!/usr/local/envs/py36/bin python3
import numpy as np
import pandas as pd
import os

# Add trailing /.
if not config["refs"]["ref_dir"].endswith("/"):
    config["refs"]["ref_dir"] += "/"
if not config["outputs"]["output_dir"].endswith("/"):
    config["outputs"]["output_dir"] += "/"
if not config["refs_extra"]["relative_phasing_dir"].endswith("/"):
    config["refs_extra"]["relative_phasing_dir"] += "/"
if not config["refs_extra"]["relative_imputation_dir"].endswith("/"):
    config["refs_extra"]["relative_imputation_dir"] += "/"

# Check if input files exist.
for plink_file_extension in [".pgen", ".pvar", ".psam"]:
    if not os.path.exists(config["inputs"]["plink_path"]):
        logger.info("Could not find the {} file. Please check that the file exists.\n\n Exiting.".format(config["inputs"]["plink_path"] + plink_file_extension))
        exit()
logger.info("Using these files as input:")
logger.info("The pgen file: " + config["inputs"]["plink_path"] + ".pgen")
logger.info("The pvar file: " + config["inputs"]["plink_path"] + ".pvar")
logger.info("The psam file: " + config["inputs"]["plink_path"] + ".psam\n")

# Check if reference files exist.
for ref_path in ["relative_vcf_path", "relative_fasta_path", "relative_map_path", "relative_imputation_path"]:
    if not os.path.exists(config["refs"]["ref_dir"] + config["refs_extra"][ref_path]):
        logger.info("Could not find the {} file. Please check that the file exists.\n\n Exiting.".format(config["refs"]["ref_dir"] + config["refs_extra"][ref_path]))
        exit()
for chr in range (1, 23):
    phasing_bcf = config["refs"]["ref_dir"] + config["refs_extra"]["relative_phasing_dir"] + "chr{}.bcf".format(chr)
    phasing_bcf_index = phasing_bcf + ".csi"
    if not os.path.exists(phasing_bcf_index) or not os.path.exists(phasing_bcf_index.index):
        logger.info("Could not find the {}(.csi) file. Please check that the file exists.\n\n Exiting.".format(phasing_bcf_index))
        exit()

    imputation_file = config["refs"]["ref_dir"] + config["refs_extra"]["relative_imputation_dir"] + "chr{}.m3vcf.gz".format(chr)
    if not os.path.exists(imputation_file):
        logger.info("Could not find the {} file. Please check that the file exists.\n\n Exiting.".format(imputation_file))
        exit()
logger.info("Found all the required reference files in " + config["refs"]["ref_dir"] + "\n")

# Check if the CHR column in the PVAR file contains the word 'chr'.
chr_in_pvar = False
with open(config["inputs"]["pvar_path"]) as f:
    for line in f:
        if "chr" in line:
            chr_in_pvar = True
            break
f.close()
if chr_in_pvar:
    logger.info("Looks like your chromosome encoding uses chr before the chromosome. For this pipeline, the chromosome encoding should not use chr. Please remove the 'chr' from your pvar file and try again. Exiting.")
    exit()

required_columns = {
    '#FID': (False, False, {}),
    'IID': (False, False, {}),
    'PAT': (True, False, {}),
    'MAT': (True, False, {}),
    'SEX': (True, False, {1: "male", 2: "female", 0: "unknown"}),
    'Provided_Ancestry': (False, True, {"AFR": "African",
                                        "AMR": "Ad Mixed American",
                                        "EAS": "East Asian",
                                        "EUR": "European",
                                        "SAS": "South Asian",
                                        "NA": "unknown"}),
    'genotyping_platform': (False, True, {}),
    'array_available': (False, True, {"Y": "yes", "N": "no"}),
    'wgs_available': (False, True, {"Y": "yes", "N": "no"}),
    'wes_available': (False, True, {"Y": "yes", "N": "no"}),
    'age': (True, True, {}),
    'age_range': (False, True, {}),
    'Study': (False, False, {}),
    'smoking_status': (False, True, {"yes": "smokes at time of sample collection",
                                     "past": "smoked in the past but not at time of sample collection",
                                     "no": "never smoked",
                                     "NA": "unknown smoking status"}),
    'hormonal_contraception_use_currently': (False, True, {"yes": "currently using hormonal contraception",
                                                           "no": "not currently using hormonal contraception",
                                                           "NA": "unknown status of contraception use or male"}),
    'menopause': (False, True, {"pre": "have not yet gone through menopause",
                                "menopause": "currently going through menopause",
                                "post": "completed menopause",
                                "NA": "unknown menopause status or male"}),
    'pregnancy_status': (False, True, {"yes": "pregnant at time of sample collection",
                                       "no": "not pregnant at time of sample collection",
                                       "NA": "unknown pregnancy status or male"})
}

# Validate the input PSAM file.
psam_df = pd.read_csv(config["inputs"]["plink_path"] + ".psam", sep="\t")
psam_df.fillna("NA", inplace=True)
missing_columns = [column for column in required_columns.keys() if not column in psam_df.columns]
if len(missing_columns) > 0:
    logger.info("The column names of your psam file are not correct.\n\
            The columns that you are missing or whose spelling does not match the required input is/are:\n{}\n\
            They should be: '#FID', 'IID', 'PAT', 'MAT', 'SEX', 'Provided_Ancestry','genotyping_platform', 'array_available', 'wgs_available','wes_available', 'age', 'age_range', 'Study', 'smoking_status', 'hormonal_contraception_use_currently', 'menopause',  'pregnancy_status'.\n\
            If the names look the same, check that the file is tab separated, without any spaces or other weird characters.\n\n\
            Exiting.".format("\n".join(missing_columns)))
    exit()

### Check for underscores in the FID and IID columns - if there are, update and make new files
for column, column_description in [("#FID", "family ids"), ("IID", "individual ids")]:
    if psam_df[column].str.contains("_").any():
        logger.info("Your {} in the psam ({} column) contain '_'.\
        Underscores are not allowed in this column due to plink operations.\n\
        Updating to dashes ('-').".format(column_description, column))
        exit()

# Check if the other columns are valid as well.
for column, (is_numeric, na_allowed, valid_values) in required_columns.items():
    # Check if numeric if need be. Some columns can have NA so then we need to only check the non NA rows.
    if is_numeric:
        values = psam_df[column]
        if na_allowed:
            values = psam_df.loc[psam_df[column] != "NA", column]
        for value in values:
            if not value.isnumeric():
                logger.info("Your {} column is not numeric, please make sure there are only numeric values in this column.\n\
                Exiting.".format(column))
                exit()

    # TODO; empty string is allowed?
    # Check if there are None or NA in the column.
    if not na_allowed and "NA" in psam_df[column]:
        logger.info("Your {} column is missing entires. NA values are not allowed in this column.\n\
        Please make sure that all contents of the study column have a string entry.\n\
        Exiting.".format(column))
        exit()

    # Check if the values correspond with the accepted input values.
    if valid_values and not psam_df[column].isin(valid_values.keys()).all():
        logger.info("Your {} column does not have just {}, please make sure all values in this column are {}.\n\
        Exiting.".format(column, ", ".join(valid_values), ", ".join(["{} ({})".format(key, value) for key, value in valid_values.items()])))
        exit()

# TODO: Not checking for np.nan, expecting all values to be non NA.
# Check that the female columns are all NA for the males.
for female_column in ["hormonal_contraception_use_currently", "menopause", "pregnancy_status"]:
    if not (psam_df.loc[psam_df["SEX"] == 1, female_column] == "NA").all():
        logger.info("There is a conflict between you SEX and your {} columns.\n\
         All males (coded by 1 in SEX) must be NA for hormonal_contraception_use_currently.\n\
         Please fix this before running the pipeline.\n\
         Exiting.".format(female_column))
        exit()

#####################
######## ALL ########
#####################
input_files = []

# Process the ancestry column in the psam.
# ancestry_update_remove.tsv is created by the pca_projection_assign rule.
ancestry_man_select_path = config["outputs"]["output_dir"] + "pca_sex_checks/ancestry_update_remove.tsv"
ancestry_updated_psam_path = config["outputs"]["output_dir"] + "pca_sex_checks/ancestry_updated.psam"
maf_man_select_path = config["outputs"]["output_dir"] + "pca_sex_checks/ancestry_mafs.tsv"
ancestry_updated_psam_df = None
if os.path.exists(ancestry_man_select_path):
    # Check if the processed psam already exists (happens if you do multiple dry_runs).
    if not os.path.exists(ancestry_updated_psam_path):
        ancestry_check = pd.read_csv(ancestry_man_select_path, sep="\t")
        if not ancestry_check.loc[ancestry_check["UPDATE/REMOVE/KEEP"].isin(['UPDATE', 'REMOVE', 'KEEP']), "UPDATE/REMOVE/KEEP"].count() == len(ancestry_check):
            logger.info("Your UPDATE/REMOVE/KEEP column in ancestry_update_remove.tsv does not have just UPDATE, REMOVE, or KEEP, please make sure all values in this column are valid.\n\
            Exiting.")
            exit()

        # if there are any individuals chosen to remove, remove them from the psam.
        ancestry_updated_psam_df = psam_df.loc[psam_df["UPDATE/REMOVE/KEEP"] != "REMOVE", :].copy()

        # if there are any individuals chosen to update the ancestry, update them in the psam.
        if "UPDATE" in psam_df["UPDATE/REMOVE/KEEP"]:
            mask = ancestry_check["UPDATE/REMOVE/KEEP"] == "UPDATE"
            ancestry_updated_psam_df.loc[mask, "Provided_Ancestry"] = ancestry_updated_psam_df.loc[mask, "PCA_Assignment"]

        # Save the updated psam.
        ancestry_updated_psam_df.to_csv(ancestry_updated_psam_path, sep="\t", na_rep="NA", index=False, header=True)
    else:
        # If the user wants to recreate it, it should just remove the existing file.
        logger.info("Warning, updated_psam.psam already exists, using existing file")
        ancestry_updated_psam_df = pd.read_csv(ancestry_updated_psam_path,sep="\t", index_col=None, header=0)

# If the ancestry have been updated we can ask the user for the MAF values.
ancestry_maf_select_path = config["outputs"]["output_dir"] + "pca_sex_checks/ancestry_mafs.tsv"
ancestry_maf_dict = {}
ANCESTRIES = []
if ancestry_updated_psam_df is not None:
    ancestry_counts = ancestry_updated_psam_df["Provided_Ancestry"].counts()
    if os.path.exists(ancestry_maf_select_path):
        # File already exists, check if the input is valid.
        maf_df = pd.read_csv(config["outputs"]["output_dir"] + "pca_sex_checks/ancestry_mafs.tsv", sep="\t", index_col=None, header=0)

        ancestries = []
        for _, row in maf_df.iterrows():
            if row["MAF"] == "NA":
                logger.info("You indicated that you don't want to impute {:,} individuals from {} ancestry.".format(ancestry_counts[row["Ancestry"]], row["Ancestry"]))
            elif not value.isnumeric():
                logger.info("Your MAF column in ancestry_mafs.tsv is not NA nor numeric, please make sure there are only numeric values in this column.\n\
                Exiting.".format(column))
                exit()
            else:
                logger.info("You indicated that you want to impute {:,} individuals from {} ancestry with MAF {}.".format(ancestry_counts[row["Ancestry"]], row["Ancestry"], row["MAF"]))
                ancestries.append(row["Ancestry"])

        maf_df["MAF"] = maf_df["MAF"].astype(float)
        ancestry_maf_dict = dict(zip(maf_df["Ancestry"], maf_df["MAF"]))
        ANCESTRIES = maf_df["Ancestry"]
    else:
        # Generate the MAF selection file.
        pd.DataFrame({'Ancestry': [ancestry for ancestry in ancestry_counts.index], 'MAF': np.nan}).to_csv(ancestry_maf_select_path, sep="\t", index=False)

# Update the sex column in the psam (rule update_sex_ancestry does this for some reason).
# sex_update_remove.tsv is created by the pca_projection_assign rule.
sex_man_select_path = config["outputs"]["output_dir"] + "pca_sex_checks/sex_update_remove.tsv"
sex_ancestry_updated_psam_path = config["outputs"]["output_dir"] + "pca_sex_checks/sex_ancestry_updated.psam"
if ancestry_updated_psam_df is not None and os.path.exists(sex_man_select_path) and not os.path.exists(sex_ancestry_updated_psam_path):
    sex_check = pd.read_csv(sex_man_select_path, sep="\t")
    if sex_check.loc[sex_check["UPDATE/REMOVE/KEEP"].isin(['UPDATE', 'REMOVE', 'KEEP']), "UPDATE/REMOVE/KEEP"].count() == len(sex_check):
        logger.info("Your UPDATE/REMOVE/KEEP column in sex_update_remove.tsv does not have just UPDATE, REMOVE, or KEEP, please make sure all values in this column are valid.\n\
        Exiting.")
        exit()

    # endpoint for rule calculate_missingness.
    input_files.append(config["outputs"]["output_dir"] + "genotype_donor_annotation/genotype_donor_annotation.tsv")

    # endpoint for rule count_snps.
    input_files.append(config["outputs"]["output_dir"] + "metrics/Number_SNPs.png")


rule all:
    input:
        input_files

############################
######## IMPUTATION ########
############################

# Import individual rules
include: "includes/plink_gender_ancestry_QC.smk"
include: "includes/urmo_imputation_hg38.smk"
